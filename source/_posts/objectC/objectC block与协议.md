---
title: block与协议
date: 2018-04-15 13:20:33
tags: 
  - "Extension"
categories: "objectC语言学习"
---
## Extension

1、 延展： Extension，是一个特殊的分类，所以延展也是类的一部分
2、 特殊之处

- 延展这个特殊的分类没有名字
- 只有声明没有实现，和本类共享一个实现

3、 延展的语法：

```
@interface 本类名 （）

@end
```
没有实现，和本类共享一个实现

3、 为类添加延展的步骤，只会生成一个.h文件，文件名：本类名_取的文件名.h，这个文件中只有延展的声明

4、 延展和分类的区别

- 分类有名字，延展没有名字，是一个匿名的分类
- 每一个分类都有单独的声明和实现，而延展只有声明，没有实现，和本类共享一个实现
- 分类中只能新增方法，而延展中任意的成员都可以写
- 分类中可以写@property但是只会生成 getter setter的声明。延展中写@property会自动生成私有属性，也会生成getter setter的声明和实现

5、 延展的应用场景

- 要为类写一个私有的@property，生成getter setter方法只能在类的内部访问，不能在外部访问
- 延展100%的情况下不会独占一个文件，都是将延展直接写在本类的实现当中。这个时候，写在延展中的成员，就相当于是这个类的私有成员，只能在本类的实现中访问，外部不能访问
- 什么时候使用延展？当想为这个类定义私有成员的时候就可以使用延展，将延展定义在这个类的实现文件中。如果想要为类写一个真私有属性，虽然可以定义在@implementation之中，但是不要这样写，不规范，需将这个类的延展定义在这个类的实现中来写真私有属性。如果为类写一个私有方法，建议将声明写在延展当中，延展写在这个类的本类实现中，提高代码的阅读性
- 延展就是用来做私有化类成员的，如果类的成员只希望在类的内部访问，那么就定义在延展当中，延展定义在本类的实现中


## block

1、 OC在C的基础之上新增了一些数据类型
BOOL、Boolean、class、nil、SEL、id、block
2、 block是一个数据类型

- block是1个数据类型，所以可以声明一个block类型的变量
- block类型的变量中专门存储1段代码，这段代码可以有参数，可以有返回值

3、 block变量的声明

- 虽然block变量中是用来存储一段代码的，但是1个block变量中并不是任意的1段代码都可以存进去的，而是有限定的，也就是说，在声明block变量的时候，必须要指定这个block变量存储的代码段是否有参数，是否有返回值。一旦指定以后，这个block变量中就只能存储这样的代码

- 声明一个block变量，返回值是void，参数是1个int类型的，这个时候，这个block变量中只能存储无返回值并且1一个int参数的代码段

- 声明block变量的语法格式：
返回值类型 (^block变量的名称)(参数列表);
```
void (^myBlock1)();//表示声明了一个block类型的变量叫做myBlock1这个变量中只能存储没有返回值没有参数的代码段
int (^myBlock2)();
int (^myBlock3)(int num1,int num2);
```

- 初始化block变量
   * 原理： 写一个符合block要求的代码段，存储到block变量中就可以了
   * 代码段的书写格式，^返回值类型(参数列表){ 代码段; }

    ```
 
     //这个时候可以使用赋值符号存储到无返回值无参数要求的myBlock1变量之中
     myBlock1 = ^void(){
         NSlog(@"i love you ");
     }
 
    ```


- 如何执行存储在block变量中的代码段
语法格式： block变量名();

- 关于block的简写
    * 如果我们写的代码段没有返回值，那么代码段的void可以省略

    ```
    // 注意 ，说的是代码段的返回值如果是void可以省略，声明block变量的返回值无论是什么，都不可以省略
    void (^myBlock1)()= ^(){
        NSLog(@"I love you");
    }
    ```
    - 如果我们写的代码段没有参数，代码段的小括弧也可以省略

    ```
    // 注意，是代码段才可以省略
    int (^myBlock2)()=^int{
        int num1 = 10+9;
        return num1;
    }
    ```
    - 当一个代码段即没有参数，也没有返回值的时候，就只写一个^

    ```
        void (^myBlock1)()= ^{
          NSLog(@"I love you");
       }
    ```
    - 声明block变量的时候，如果有指定参数，可以只写参数的类型而不写参数的名称
    ```
      // 注意，这个地方指的是声明block变量的时候，写代码段的时候，类型和名称都要写
      int (^myBlock3)(int,int)= ^int(int num1,int num2){
          int num3= num1 +num2;
          return num3;
      }
    ```
    - 无论代码段是否有返回值的时候，都可以省略返回值类型
    ```
      // 如果在写代码段的时候，省略了返回值，系统会自动判断返回类型
      int (^myBlock3)(int,int)=^(int num1,int num2){
          int num3= num1+num2;
          return num3;
      }
    ```


- 简化block百年来的复杂定义

     * 定义block变量的时候，要写好大1串，类型很长
     * typedef的使用场景： 将一个长类型定义为一个短类型
     * 可以使用typedef将长的block类型，定义为一个短类型
     typedef 返回值类型 (^新类型)(参数列表);

     ```
        typedef void (^NewType)();
        // 代表重新定义了一个无参数无返回值的block类型NewType
        NewType block1;
     ```


- block 内部访问外部变量的问题

    * 在block代码块的内部可以取定义在外部变量的值，定义在外部的局部变量和全局变量的值
    * 在block代码块的内部可以修改全局变量的值，但是不可以修改定义在外部的局部变量的值
    * 如果希望定义的局部变量可以允许在block代码段的内部去修改，那么就为这个局部变量加一个__block修饰符即可


## block 作为函数的参数

1、 如何为函数定义block类型的参数？

- 在小括弧中声明一个指定格式的block变量就可以了
- 可以使用typedef简化定义

2、 如何去调用带block参数的函数

- 如果要调用的函数参数是block类型，那么要求在调用的时候传入一个和形参block要求的代码段

```

#import <Foundation/Foundation.h>
typedef void (^NewType)(void);
//为这个函数定义一个参数，定义1个block类型的参数
//无参数的无返回值的block
void test(NewType block1)
{
    NSLog(@"~~~~~~~~~~~~");
    block1();
    NSLog(@"~~~~~~~~~~~~");
}
void test2(int (^paramsBlock)(int num1,int num2)){
    NSLog(@"^^^^^^^^^^^^");
    int sum= paramsBlock(10,20);
    NSLog(@"%d",sum);
    NSLog(@"^^^^^^^^^^^^");
}
int main(int argc, const char * argv[]) {
    NewType type=^{
        NSLog(@"哈哈");
        NSLog(@"呵呵");
        NSLog(@"嘿嘿");
    };
    test(type);
    test(^{
        NSLog(@"hello");
    });
    test2(^int(int num1, int num2) {
        int sum=num1+num2;
        return sum;
    });
    return 0;
}

```

3、 应用场景

- 可以将调用者自己写的一段代码，传入到函数内部执行

- 当方法的内部需要执行一个功能，但是这个功能具体的实现函数内部不确定，那么这个时候就使用block让调用者将这个功能的具体实现传递进去




## block 作为函数的返回值

1、 如果block作为函数的返回值，返回值类型必须使用typedef定义的短类型返回，否则报错

```
typedef void (^NewType2)(void);
NewType2 test3()
{
    void (^block1)()=^{
        NSLog(@"^^^^^^");
        NSLog(@"hello newType2");
        NSLog(@"^^^^^^");
    };
    return block1;
}
int main(int argc, const char * argv[]) {
    NewType2 blockNewType2=test3();
    blockNewType2();
}
```

## block 与函数

1、 相同点 ： 都是封装一段代码。不同点：

- block是一个数据类型，函数是一个函数
- 可以声明一个block类型的变量，函数只能是函数
- block可以作为函数的参数，而函数不能直接作为函数的参数，可以使用函数指针来作为函数参数


## protocol

1、协议：protocol，作用：专门用来声明一大堆方法（不能声明属性，也不能实现方法，只能用来写方法的声明） 只要某个类遵守这个协议，就相当于拥有这个协议中的所有方法的声明，而不用自己定义

2、 协议的声明

@protocol 协议名称 <NSObject>
方法的声明;
@end

>新建一个协议的方式  NewFile  OC-File  选择protocol ，协议的文件名： .h 并且只有一个.h文件，在协议中，只能用来声明方法，协议的作用：就是专门用来写方法的声明

3、 类遵守协议

>协议就是用来写方法声明的，就是用来被类遵守的，如果想要让1个类，拥有协议中定义的所有的方法声明，那么就让这个类遵守这个协议，类只要遵守一个协议，那么这个类就拥有了这些协议中定义的所有方法声明

@interface 类名 ： 父类名 <协议名称>

@end

：表示继承
<> 表示遵守的协议

当一个类，遵守了1个协议，那么就先相当于这个类拥有了协议中定义的所有的方法声明，这个类只是拥有这个协议中的方法声明而已，没有实现，所以这个类，就应该实现协议中的方法

如果类不实现协议中的方法，其实也不会报错，编译器只是会报警告，但是当创建对象，来调用这个没有实现的协议中的方法的时候，就会报错

4、 类是单继承，但是协议可以多遵守

>1个类只能有一个父类，但是1个类可以同时遵守多个协议

@interface 类名: 父类名 <协议名称1,协议名称2……>
@end
当一个类遵守了多个协议之后，就相当于这个类拥有了所有协议中定义的方法声明，那么这个类就应该实现所有协议中的方法

5、 @required 和 @optional 
 > 这两个修饰符是专门用来修饰协议中的方法，在协议中，如果方法的声明被@required修饰，那么遵守这个协议的类必须实现这个方法，否则编译器会出警告。如果方法的声明被@optional修饰，遵守这个协议的类可以不去实现这个方法，不实现编译器也不会报警告。默认是@required

6、 协议与协议之间可以相互继承

> 语法：
@protocol 协议名称 <父协议名称>
@end

> 效果
子协议当中不仅有自己的方法声明，还有父协议的方法声明

7、 NSObject，在Foundation框架中，有1个类叫做NSObject，是所有OC类的鸡肋。在Foundation框架中，有一个协议，叫做NSObject.
> NSObject 协议被NSObject类遵守，所以NSObject协议中的所有方法，全部的OC类都拥有了，所有的OC类都遵守了NSObject协议，NSObject协议叫做基协议

>类的名称可以和协议的名称一致

8、规范
> 要求所有的协议都必须直接的或者间接的从NSObject基协议继承

9、协议的类型限制




