---
title: 位运算
date: 2018-04-12 12:41:33
tags: 
  - "位运算"
categories: "c语言学习"
---
## 位运算的概念
 指的是1个二进制数据的每一位都来参加运算，前提是这个数必须是一个二进制数
 
 注意点
 - 参加位运算的二进制数据必须是补码的形式
 - 位运算的结果也是二进制的补码形式
 

## 按位与：&

参入按位与的两个二进制数。如果都为1 那么结果就都是 1 只要1位为0 那么结果就为0

3&2；

第一个步骤：先得到两个数的二进制补码形式

3的补码：  00000000 00000000 00000000 00000011

2的补码：  00000000 00000000 00000000 00000010

计算的结果 00000000 00000000 00000000 00000010  结果就是2
           
-3&4；

-3的原码： 10000000 00000000 00000000 00000011

-3的反码： 11111111 11111111 11111111 11111100

-3的补码： 11111111 11111111 11111111 11111101

4的补码：  00000000 00000000 00000000 00000100

计算结果： 00000000 00000000 00000000 00000100 结果就是 4

-3&-4;

-4的原码： 10000000 00000000 00000000 00000100

-4的反码： 11111111 11111111 11111111 11111011

-4的补码： 11111111 11111111 11111111 11111100

-3的补码： 11111111 11111111 11111111 11111101

计算结果： 11111111 11111111 11111111 11111100 结果是补码

结果反码： 11111111 11111111 11111111 11111011

结果原码： 10000000 00000000 00000000 00000100 结果就是 -4

任何一个数&1，结果就是这个数的最低位。即偶数的最低位一定是0，奇数的最低位一定是1。所以判断这个数是奇数还是偶数，只要用这个数按位与1就可以了。 如果结果为1 那么就是奇数 如果结果为0 那么就是偶数

int num=10;
if((num&1)==0){
    偶数；
}else{
    奇数；
}

## 按位或。 |

只要有1位是1 ，那么结果就为1 只有当两位都是0的时候结果才是0

3|2；
3的补码：00000000 00000000 00000000 00000011

2的补码：00000000 00000000 00000000 00000010

计算   ：00000000 00000000 00000000 00000011 结果为3

-3|4；

-3的原码： 10000000 00000000 00000000 00000011

-3的反码： 11111111 11111111 11111111 11111100

-3的补码： 11111111 11111111 11111111 11111101

4的补码：  00000000 00000000 00000000 00000100

计算结果： 11111111 11111111 11111111 11111101 结果就是补码

结果反码： 11111111 11111111 11111111 11111100

结果补码： 10000000 00000000 00000000 00000011 结果就是-3


-3|-4;

-4的原码： 10000000 00000000 00000000 00000100

-4的反码： 11111111 11111111 11111111 11111011

-4的补码： 11111111 11111111 11111111 11111100

-3的补码： 11111111 11111111 11111111 11111101

计算结果： 11111111 11111111 11111111 11111101 结果是补码

结果反码： 11111111 11111111 11111111 11111100

结果原码： 10000000 00000000 00000000 00000011 结果就是 -3

## 按位取反： ～
  单目运算符，将二进制的每一位取反
  
  ～3；
  3的补码： 000000000 00000000 00000000 00000011
  
  计算：    111111111 11111111 11111111 11111100 结果是补码
  
  结果反码  111111111 11111111 11111111 11111011
  
  结果补码  100000000 00000000 00000000 00000100 结果是-4
  
  ## 按位异或： ^ 
  参入按位异或的二进制的位 如果相同位0 不同为1
  
  3^2
  
  3^2；
3的补码：00000000 00000000 00000000 00000011

2的补码：00000000 00000000 00000000 00000010

计算   ：00000000 00000000 00000000 00000001 结果为1

交换两个变量的值可以用异或运算
int a=2;
int b=3;

a=a^b; a=1

b=a^b; b=3

a=a^b; a=2

## 按位左移运算 <<
参入按位左移运算的二进制数据。向左移动指定的位数。低位不够补0 高位溢出则丢弃

3 << 2;

3的补码： 000000000 00000000 00000000 00000011

左移：    000000  00000000 00000000 00001100 结果为12

注意：
- 左移运算有可能改变其正负性
- 将一个数左移n位，相当于将这个数 乘以 2的n次方


3 << 2  3乘以2的2次方
16 << 3; 16*8
5 << 4; 5*16

## 按位右移 >>

参入按位右移的二进制数据。向又移动指定的位数，低位溢出丢弃，高位补符号位，正数就补0 ，负数就补1

3 >>2 ;

3的补码 00000000 00000000 00000000 00000011

右移结果  00000000 00000000 00000000 00000000 结果为0

16 >>2;
16的补码 00000000 00000000 00000000 00100000

右移结果   00000000 00000000 00000000 00000100  结果为4

-16 >>3;
-16 的原码 1000 0000 0000 0000 0000 0000 0001 0000

-16 的反码 1111 1111 1111 1111 1111 1111 1110 1111

-16 的补码 1111 1111 1111 1111 1111 1111 1111 0000

右移结果      1 1111 1111 1111 1111 1111 1111 1110

补足符号位 1111 1111 1111 1111 1111 1111 1111 1110 

补足反码   1111 1111 1111 1111 1111 1111 1111 1101

补足原码   1000 0000 0000 0000 0000 0000 0000 0010 结果为-2

注意：
- 右移运算不会改变正负性
- 1个数按位右移n位 相当于除以 2的n次方

100 >> 2    === 100/4


  
  
  


